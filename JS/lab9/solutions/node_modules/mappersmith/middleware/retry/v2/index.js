"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultRetryConfigs = exports["default"] = exports.calculateExponentialRetryTime = void 0;

var _index = require("../../../index");

var _utils = require("../../../utils");

var _response = require("../../../response");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var defaultRetryConfigs = {
  headerRetryCount: 'X-Mappersmith-Retry-Count',
  headerRetryTime: 'X-Mappersmith-Retry-Time',
  maxRetryTimeInSecs: 5,
  initialRetryTimeInSecs: 0.1,
  factor: 0.2,
  // randomization factor
  multiplier: 2,
  // exponential factor
  retries: 5,
  // max retries
  validateRetry: function validateRetry(response) {
    return response.responseStatus >= 500;
  } // a function that returns true if the request should be retried

};
exports.defaultRetryConfigs = defaultRetryConfigs;

/**
 * This middleware will automatically retry GET requests up to the configured amount of
 * retries using a randomization function that grows exponentially. The retry count and
 * the time used will be included as a header in the response.
 *
 * The retry time is calculated using the following formula:
 *   retryTime = min(
 *     random(previousRetryTime - randomizedFactor, previousRetryTime + randomizedFactor) * multipler,
 *     maxRetryTime
 *   )
 *
 * Take a look at `calculateExponentialRetryTime` for more information.
 *
 *  @param {Object} retryConfigs
 *   @param {String} retryConfigs.headerRetryCount (default: 'X-Mappersmith-Retry-Count')
 *   @param {String} retryConfigs.headerRetryTime (default: 'X-Mappersmith-Retry-Time')
 *   @param {Number} retryConfigs.maxRetryTimeInSecs (default: 5)
 *   @param {Number} retryConfigs.initialRetryTimeInSecs (default: 1)
 *   @param {Number} retryConfigs.factor (default: 0.2) - randomization factor
 *   @param {Number} retryConfigs.multiplier (default: 2) - exponential factor
 *   @param {Number} retryConfigs.retries (default: 5) - max retries
 */
var _default = function _default() {
  var customConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function RetryMiddleware() {
    return {
      request: function request(_request) {
        this.enableRetry = _request.method() === 'get';
        this.inboundRequest = _request;
        return _request;
      },
      response: function response(next) {
        var retryConfigs = (0, _utils.assign)({}, defaultRetryConfigs, customConfigs);
        var inboundRequest = this.inboundRequest;

        if (!this.enableRetry) {
          return next();
        }

        if (!_index.configs.Promise) {
          return next();
        }

        if (!inboundRequest) {
          return next();
        }

        return new _index.configs.Promise(function (resolve, reject) {
          var retryTime = retryConfigs.initialRetryTimeInSecs * 1000;
          retriableRequest(resolve, reject, next, inboundRequest)(randomFromRetryTime(retryTime, retryConfigs.factor), 0, retryConfigs);
        });
      }
    };
  };
};

exports["default"] = _default;

var retriableRequest = function retriableRequest(resolve, reject, next, request) {
  var retry = function retry(retryTime, retryCount, retryConfigs) {
    var nextRetryTime = calculateExponentialRetryTime(retryTime, retryConfigs);
    var shouldRetry = retryCount < retryConfigs.retries;

    var scheduleRequest = function scheduleRequest() {
      setTimeout(function () {
        return retry(nextRetryTime, retryCount + 1, retryConfigs);
      }, retryTime);
    };

    next().then(function (response) {
      if (shouldRetry && retryConfigs.validateRetry(response)) {
        scheduleRequest();
      } else {
        try {
          resolve(enhancedResponse(response, retryConfigs.headerRetryCount, retryCount, retryConfigs.headerRetryTime, retryTime));
        } catch (e) {
          var errorMessage = '';

          if (response instanceof Error) {
            errorMessage = response.message;
          }

          if (_typeof(e) === 'object' && e !== null && 'message' in e) {
            errorMessage = e.message;
          }

          reject(new _response.Response(request, 400, errorMessage, {}, [response]));
        }
      }
    })["catch"](function (response) {
      if (shouldRetry && retryConfigs.validateRetry(response)) {
        scheduleRequest();
      } else {
        try {
          reject(enhancedResponse(response, retryConfigs.headerRetryCount, retryCount, retryConfigs.headerRetryTime, retryTime));
        } catch (e) {
          var errorMessage = '';

          if (response instanceof Error) {
            errorMessage = response.message;
          }

          if (_typeof(e) === 'object' && e !== null && 'message' in e) {
            errorMessage = e.message;
          }

          reject(new _response.Response(request, 400, errorMessage, {}, [response]));
        }
      }
    });
  };

  return retry;
};
/**
 * Increases the retry time for each attempt using a randomization function that grows exponentially.
 * The value is limited by `retryConfigs.maxRetryTimeInSecs`.
 * @param {Number} retryTime
 *
 * @return {Number}
 */


var calculateExponentialRetryTime = function calculateExponentialRetryTime(retryTime, retryConfigs) {
  return Math.min(randomFromRetryTime(retryTime, retryConfigs.factor) * retryConfigs.multiplier, retryConfigs.maxRetryTimeInSecs * 1000);
};

exports.calculateExponentialRetryTime = calculateExponentialRetryTime;

var randomFromRetryTime = function randomFromRetryTime(retryTime, factor) {
  var delta = factor * retryTime;
  return random(retryTime - delta, retryTime + delta);
};

var random = function random(min, max) {
  return Math.random() * (max - min) + min;
};

var enhancedResponse = function enhancedResponse(response, headerRetryCount, retryCount, headerRetryTime, retryTime) {
  var _headers;

  return response.enhance({
    headers: (_headers = {}, _defineProperty(_headers, headerRetryCount, retryCount), _defineProperty(_headers, headerRetryTime, retryTime), _headers)
  });
};