"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ClientBuilder = void 0;

var _manifest = require("./manifest");

var _request = require("./request");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isFactoryConfigured = function isFactoryConfigured(factory) {
  if (!factory || !factory()) {
    return false;
  }

  return true;
};
/**
 * @typedef ClientBuilder
 * @param {Object} manifestDefinition - manifest definition with at least the `resources` key
 * @param {Function} GatewayClassFactory - factory function that returns a gateway class
 */


var ClientBuilder = /*#__PURE__*/function () {
  function ClientBuilder(manifestDefinition, GatewayClassFactory, configs) {
    _classCallCheck(this, ClientBuilder);

    _defineProperty(this, "Promise", void 0);

    _defineProperty(this, "manifest", void 0);

    _defineProperty(this, "GatewayClassFactory", void 0);

    _defineProperty(this, "maxMiddlewareStackExecutionAllowed", void 0);

    if (!manifestDefinition) {
      throw new Error("[Mappersmith] invalid manifest (".concat(manifestDefinition, ")"));
    }

    if (!isFactoryConfigured(GatewayClassFactory)) {
      throw new Error('[Mappersmith] gateway class not configured (configs.gateway)');
    }

    if (!configs.Promise) {
      throw new Error('[Mappersmith] Promise not configured (configs.Promise)');
    }

    this.Promise = configs.Promise;
    this.manifest = new _manifest.Manifest(manifestDefinition, configs);
    this.GatewayClassFactory = GatewayClassFactory;
    this.maxMiddlewareStackExecutionAllowed = configs.maxMiddlewareStackExecutionAllowed;
  }

  _createClass(ClientBuilder, [{
    key: "build",
    value: function build() {
      var _this = this;

      var client = {
        _manifest: this.manifest
      };
      this.manifest.eachResource(function (resourceName, methods) {
        client[resourceName] = _this.buildResource(resourceName, methods);
      });
      return client;
    }
  }, {
    key: "buildResource",
    value: function buildResource(resourceName, methods) {
      var _this2 = this;

      var initialResourceValue = {};
      var resource = methods.reduce(function (resource, method) {
        var resourceMethod = function resourceMethod(requestParams) {
          var request = new _request.Request(method.descriptor, requestParams); // `resourceName` can be `PropertyKey`, making this `string | number | Symbol`, therefore the string conversion
          // to stop type bleeding.

          return _this2.invokeMiddlewares(String(resourceName), method.name, request);
        };

        return _objectSpread(_objectSpread({}, resource), {}, _defineProperty({}, method.name, resourceMethod));
      }, initialResourceValue); // @hint: This type assert is needed as the compiler cannot be made to understand that the reduce produce a
      // non-partial result on a partial input. This is due to a shortcoming of the type signature for Array<T>.reduce().
      // @link: https://github.com/microsoft/TypeScript/blob/v3.7.2/lib/lib.es5.d.ts#L1186

      return resource;
    }
  }, {
    key: "invokeMiddlewares",
    value: function invokeMiddlewares(resourceName, resourceMethod, initialRequest) {
      var _this3 = this;

      var middleware = this.manifest.createMiddleware({
        resourceName: resourceName,
        resourceMethod: resourceMethod
      });
      var GatewayClass = this.GatewayClassFactory();
      var gatewayConfigs = this.manifest.gatewayConfigs;
      var requestPhaseFailureContext = {
        middleware: null,
        returnedInvalidRequest: false,
        abortExecution: false
      };

      var getInitialRequest = function getInitialRequest() {
        return _this3.Promise.resolve(initialRequest);
      };

      var chainRequestPhase = function chainRequestPhase(next, middleware) {
        return function () {
          var abort = function abort(error) {
            requestPhaseFailureContext.abortExecution = true;
            throw error;
          };

          return _this3.Promise.resolve().then(function () {
            return middleware.prepareRequest(next, abort);
          }).then(function (request) {
            if (request instanceof _request.Request) {
              return request;
            } // FIXME: Here be dragons: prepareRequest is typed as Promise<Response | void>
            // but this code clearly expects it can be something else... anything.
            // Hence manual cast to `unknown` above.


            requestPhaseFailureContext.returnedInvalidRequest = true;

            var typeValue = _typeof(request);

            var prettyType = typeValue === 'object' || typeValue === 'function' ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
            request.name || typeValue : typeValue;
            throw new Error("[Mappersmith] middleware \"".concat(middleware.__name, "\" should return \"Request\" but returned \"").concat(prettyType, "\""));
          })["catch"](function (e) {
            requestPhaseFailureContext.middleware = middleware.__name || null;
            throw e;
          });
        };
      };

      var prepareRequest = middleware.reduce(chainRequestPhase, getInitialRequest);
      var executions = 0;

      var executeMiddlewareStack = function executeMiddlewareStack() {
        return prepareRequest()["catch"](function (e) {
          var returnedInvalidRequest = requestPhaseFailureContext.returnedInvalidRequest,
              abortExecution = requestPhaseFailureContext.abortExecution,
              middleware = requestPhaseFailureContext.middleware;

          if (returnedInvalidRequest || abortExecution) {
            throw e;
          }

          var error = new Error("[Mappersmith] middleware \"".concat(middleware, "\" failed in the request phase: ").concat(e.message));
          error.stack = e.stack;
          throw error;
        }).then(function (finalRequest) {
          executions++;

          if (executions > _this3.maxMiddlewareStackExecutionAllowed) {
            throw new Error("[Mappersmith] infinite loop detected (middleware stack invoked ".concat(executions, " times). Check the use of \"renew\" in one of the middleware."));
          }

          var renew = executeMiddlewareStack;

          var chainResponsePhase = function chainResponsePhase(previousValue, currentValue) {
            return function () {
              // Deliberately putting this on two separate lines - to get typescript to not return "any"
              var nextValue = currentValue.response(previousValue, renew);
              return nextValue;
            };
          };

          var callGateway = function callGateway() {
            return new GatewayClass(finalRequest, gatewayConfigs).call();
          };

          var execute = middleware.reduce(chainResponsePhase, callGateway);
          return execute();
        });
      };

      return new this.Promise(function (resolve, reject) {
        executeMiddlewareStack().then(function (response) {
          return resolve(response);
        })["catch"](reject);
      });
    }
  }]);

  return ClientBuilder;
}();

exports.ClientBuilder = ClientBuilder;
var _default = ClientBuilder;
exports["default"] = _default;