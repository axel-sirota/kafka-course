"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validKeys = exports.toQueryString = exports.performanceNow = exports.parseResponseHeaders = exports.lowerCaseObjectKeys = exports.isPlainObject = exports.isObject = exports.buildRecursive = exports.btoa = exports.assign = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var _process, getNanoSeconds, loadTime;

try {
  // eslint-disable-next-line no-eval
  _process = eval('typeof __TEST_WEB__ === "undefined" && typeof process === "object" ? process : undefined');
} catch (e) {} // eslint-disable-line no-empty


var hasProcessHrtime = function hasProcessHrtime() {
  return typeof _process !== 'undefined' && _process !== null && _process.hrtime;
};

if (hasProcessHrtime()) {
  getNanoSeconds = function getNanoSeconds() {
    var hr = _process.hrtime();

    return hr[0] * 1e9 + hr[1];
  };

  loadTime = getNanoSeconds();
}

var R20 = /%20/g;

var isNeitherNullNorUndefined = function isNeitherNullNorUndefined(x) {
  return x !== null && x !== undefined;
};

var validKeys = function validKeys(entry) {
  return Object.keys(entry).filter(function (key) {
    return isNeitherNullNorUndefined(entry[key]);
  });
};

exports.validKeys = validKeys;

var buildRecursive = function buildRecursive(key, value) {
  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var encoderFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : encodeURIComponent;

  if (Array.isArray(value)) {
    return value.map(function (v) {
      return buildRecursive(key, v, suffix + '[]', encoderFn);
    }).join('&');
  }

  if (_typeof(value) !== 'object') {
    return "".concat(encoderFn(key + suffix), "=").concat(encoderFn(value));
  }

  return Object.keys(value).map(function (nestedKey) {
    var nestedValue = value[nestedKey];

    if (isNeitherNullNorUndefined(nestedValue)) {
      return buildRecursive(key, nestedValue, suffix + '[' + nestedKey + ']', encoderFn);
    }

    return null;
  }).filter(isNeitherNullNorUndefined).join('&');
};

exports.buildRecursive = buildRecursive;

var toQueryString = function toQueryString(entry) {
  var encoderFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : encodeURIComponent;

  if (!isPlainObject(entry)) {
    return entry;
  }

  return Object.keys(entry).map(function (key) {
    var value = entry[key];

    if (isNeitherNullNorUndefined(value)) {
      return buildRecursive(key, value, '', encoderFn);
    }

    return null;
  }).filter(isNeitherNullNorUndefined).join('&').replace(R20, '+');
};
/**
 * Gives time in milliseconds, but with sub-millisecond precision for Browser
 * and Nodejs
 */


exports.toQueryString = toQueryString;

var performanceNow = function performanceNow() {
  if (hasProcessHrtime() && getNanoSeconds !== undefined) {
    var now = getNanoSeconds();

    if (now !== undefined && loadTime !== undefined) {
      return (now - loadTime) / 1e6;
    }
  }

  return Date.now();
};
/**
 * borrowed from: {@link https://gist.github.com/monsur/706839}
 * XmlHttpRequest's getAllResponseHeaders() method returns a string of response
 * headers according to the format described here:
 * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}
 * This method parses that string into a user-friendly key/value pair object.
 */


exports.performanceNow = performanceNow;

var parseResponseHeaders = function parseResponseHeaders(headerStr) {
  var headers = {};

  if (!headerStr) {
    return headers;
  }

  var headerPairs = headerStr.split("\r\n");

  for (var i = 0; i < headerPairs.length; i++) {
    var headerPair = headerPairs[i]; // Can't use split() here because it does the wrong thing
    // if the header value has the string ": " in it.

    var index = headerPair.indexOf(": ");

    if (index > 0) {
      var key = headerPair.substring(0, index).toLowerCase().trim();
      var val = headerPair.substring(index + 2).trim();
      headers[key] = val;
    }
  }

  return headers;
};

exports.parseResponseHeaders = parseResponseHeaders;

var lowerCaseObjectKeys = function lowerCaseObjectKeys(obj) {
  return Object.keys(obj).reduce(function (target, key) {
    target[key.toLowerCase()] = obj[key];
    return target;
  }, {});
};

exports.lowerCaseObjectKeys = lowerCaseObjectKeys;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var assign = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    // eslint-disable-next-line prefer-rest-params
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.assign = assign;
var toString = Object.prototype.toString;

var isPlainObject = function isPlainObject(value) {
  return toString.call(value) === '[object Object]' && Object.getPrototypeOf(value) === Object.getPrototypeOf({});
};

exports.isPlainObject = isPlainObject;

var isObject = function isObject(value) {
  return _typeof(value) === 'object' && value !== null && !Array.isArray(value);
};
/**
 * borrowed from: {@link https://github.com/davidchambers/Base64.js}
 */


exports.isObject = isObject;
var CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var btoa = function btoa(input) {
  var output = '';
  var map = CHARS;
  var str = String(input);

  for ( // initialize result and counter
  var block = 0, charCode, idx = 0; // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xff) {
      throw new Error("[Mappersmith] 'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }

    block = block << 8 | charCode;
  }

  return output;
};

exports.btoa = btoa;